package Day13;
/*
进程：正在运行的程序称为进程，进程负责了内存空间的分配。

windows号称是多任务的操作系统，那么windows是同时运行多个应用程序？

     从宏观的角度：windows确实是在同时运行多个应用程序
     从微观的角度：cpu做了快速的切换执行的动作，因为速度太快所以我们感觉不到在切换而已

    单核的cpu在一个时间片只能执行一个应用程序
    各个程序其实是在做CPU争夺战而已，cpu做了快速的切换动作


线程：线程在一个进程中负责了代码的执行，就是进程的一个执行路径

多线程：在一个进程中有多个线程同时执行不同的任务

问题：线程负责了代码的执行，我们之前没有学过线程为什么代码可以执行呢？
      因为一个java程序，jvm在运行的时候都会创建一个main线程执行main方法中所有代码

一个java至少有几个线程？？
 至少有两个线程，一个是主线程负责main方法代码的执行，一个是垃圾回收器线程负责了回收垃圾

   与其说是在进程做CPU的资源争夺赛，还不如说是线程在做cpu的资源争夺战

 多线程的好处：
     1.一个进程可以执行多个任务的问题。
     2.提高了资源的利用率，而不是效率

     多线程的弊端：
     1.增加了CPU的负担。
     2.降低了一个进程中线程的执行概率
     3.引发了线程安全问题
     4.出现了死锁现象

 创建线程的方法有两种：
       创建线程的方式：
          1：自定义一个类继承Thread类
          2: 重写Thread的run方法
        疑问：重写run方法的目的是干什么？
        每个线程都有自己的任务代码。jvm创建的主线程的任务代码就是main方法中的所有代码，自定义线程的任务代码，就写在run方法中，自定义线程负责了run方法的执行
        3.创建Thread的子类对象，并且调用start方法开启线程。
            一个线程一旦开启，线程就会执行run方法中的代码，run方法千万不能直接调用，调用run方法相当于调用了一个普通的方法而已并没有开启新的线程


        线程的生命周期
        CPU的等待资格
        CPU的执行权

          临时阻塞状态
         运行状态下的线程一旦执行    sleep或者是wait方法之后，那么该线程会进入 临时阻塞状态  ,如果线程调用了sleep方法进入了
         临时阻塞状态   那么线程一旦超过了指定的睡眠时间，就会重新进入可运行状态，如果是调用了wait方法进入的临时阻塞状态 ，
         那么需要其他线程才能   唤醒  该线程，才可以重新进入可运行状态



        创建状态即new 线程对象
        创建状态既不具备等待资格也不具备执行权
                                  ---------<------   临时阻塞状态  -----wait------<----sleep------<--
                                 |                                   (唤醒）       （超过睡眠时间）   |
                                 V                                   notify                         |
        创建------>start()---->可运行状态<----得到CPU的执行权(一旦被抢回了执行权回到可运行状态)------>运行状态----->完成了任务---->死亡状态
         可运行状态具备CPU的等待资格，不具备CPU的执行权
         运行状态下的线程具备了CPU的执行权与等待资格
         summary:创建状态，可运行状态，运行状态，死亡状态，临时阻塞状态

 */



public class Safe_Line extends Thread{



    @Override//把自定义线程的任务代码写在run方法中
    public void run() {//shift+g----->Override Methods--->选择要重写的方法
        for(int i=0;i<100;i++){
            System.out.println("自定义线程："+i);
        }


    }

    public static void main(String []args){
        //创建了自定义的线程对象
        Safe_Line s = new Safe_Line();
        //调用start方法启动线程
        s.start();
        for(int i=0;i<100;i++){
            System.out.println("main线程："+i);
        }
    }
}
